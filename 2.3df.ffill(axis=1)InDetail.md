Great question! When using `df.ffill(axis=1)` to fill missing values along **columns** (horizontally), pandas tries to propagate the previous column's value to fill the missing value in the current column. However, when the **data types of adjacent columns differ**, here's what happens:

---

### **Key Points to Understand:**

1.  **Forward Filling Logic**:
    - Pandas attempts to **propagate values as-is**, without converting data types, if possible.
    - If the missing value is of type `float`, but the previous value comes from a column with `string` type, pandas cannot cast a `string` value to a `float` type.

2.  **Result**:
    - The missing value remains **unfilled** (`NaN`).
    - Pandas does **not** perform implicit type conversion (e.g., converting a string to a float) when filling values.

---

### **Example Demonstration:**

```python
import pandas as pd
import numpy as np

# Create a DataFrame
df = pd.DataFrame({
    'A': [1.5, 2.5, np.nan],
    'B': ['text', 'value', 'word'],
    'C': [np.nan, 5.5, 6.5]
})

# Apply forward fill along columns (axis=1)
df_filled = df.ffill(axis=1)

print(df_filled)
```

**Output**:

|   | A     | B      | C    |
|---|-------|--------|------|
| 0 | 1.5   | text   | NaN  |
| 1 | 2.5   | value  | 5.5  |
| 2 | NaN   | word   | 6.5  |

---

### **Explanation of the Behavior:**

- **Row 0**:
    - Column `C` is missing (`NaN`).
    - Previous column (`B`) contains a `string` value (`"text"`).
    - Since `"text"` cannot be converted into a `float`, the value in column `C` remains `NaN`.

- **Row 1**:
    - Column `C` is missing (`NaN`).
    - Previous column (`B`) contains a `string` value (`"value"`).
    - Same logic applies â€” `"value"` cannot fill `NaN` in column `C`.

- **Row 2**:
    - Column `A` is missing (`NaN`).
    - Previous column (`B`) contains a `string` value (`"word"`).
    - `"word"` cannot replace the `NaN`.

---

### **General Rules When Forward Filling Across Columns (axis=1):**

1.  If the **data types are incompatible** (e.g., `float` vs `string`), pandas **skips the fill** and leaves the value as `NaN`.
2.  No automatic type conversion occurs. Forward fill respects the existing column's data type.
3.  If all columns are of the **same type**, forward fill works as expected.

---

### **How to Handle This Situation?**

If you want to **force-fill missing values across columns** regardless of data type, you can:

#### 1. **Convert All Columns to Strings**:

```python
df_filled = df.astype(str).ffill(axis=1)
print(df_filled)
```

**Output**:

|   | A     | B      | C      |
|---|-------|--------|--------|
| 0 | 1.5   | text   | text   |
| 1 | 2.5   | value  | value  |
| 2 | nan   | word   | word   |

---

#### 2. **Handle Data Type-Specific Filling**:

For finer control, selectively fill columns based on their data type:

```python
# Forward fill for float columns
df.loc[:, df.select_dtypes(include=['float']).columns] = df.select_dtypes(include=['float']).ffill(axis=1)

# Forward fill for string columns
df.loc[:, df.select_dtypes(include=['object']).columns] = df.select_dtypes(include=['object']).ffill(axis=1)
